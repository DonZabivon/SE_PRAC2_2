#ifndef COMMAND_H
#define COMMAND_H

/*
№ Команда Семантика команды
1 BEGIN Перевод процессора в режим исполнения команд.
2 END Остановка выполнения команд.
3 PUSH value0 Добавление на вершину стека числа value0.
4 POP Удаление числа из вершины стека.
5 PUSHR reg0 Чтение регистра reg0 и добавление его на вершину стека.
6 POPR reg0 Удаление числа из вершины стека и его запись в регистр reg0.
7 ADD Сложение двух верхних значений из стека с сохранением результата на вершине стека.
8 SUB Вычитание двух верхних значений из стека с сохранением результата на вершине стека.
9 MUL Умножение двух верхних значений из стека с сохранением результата на вершине стека.
10 DIV Деление двух верхних значений из стека с сохранением результата на вершине стека.
11 OUT Удаление числа из вершины стека с выводом в консоль.
12 IN Считывание из консоли числа с сохранением на вершине стека.
13 JMP label Безусловный переход на метку label.
14 JEQ label Условный переход на метку label, если верхние два числа на стеке равны.
15 JNE label Условный переход на метку label, если верхние два числа на стеке не равны.
16 JA label Условный переход на метку label, если верхнее число на стеке больше следующего за ним.
17 JAE label Условный переход на метку label, если верхнее число на стеке больше следующего за ним или равно ему.
18 JB label Условный переход на метку label, если верхнее число на стеке меньше следующего за ним.
19 JBE label Условный переход на метку label, если верхнее число на стеке меньше следующего за ним или равно ему.
20 CALL label Вызов функции, тело которой располагается по метке label.
21 RET Возврат из функции.
*/

/* Семантика.
  Значением value0 может быть любое 32-битное целое число со знаком.
  Значением reg0 будет символ 'R' и номер регистра (R0 - R255).
  Значением label в команде может быть любая последовательность символов без пробелов.
  Команда помечается меткой, за которой сразу идет двоеточие, после которого должен
  идти хотя бы один пробельный символ, например:
    LABEL1: BEGIN
    LABEL2:
            PUSH 1
            JMP LABEL1

  При недопустимых операциях на стеке эмулятор выведет сообщение об ошибке и
  прекратит выполнение программы.

  Арифметические команды выталкивают из стека два числа, и затем помещают на стек результат.

  Команды условного перехода выталкивают из стека два числа.

  Команда CALL помещает на стек адрес возврата (адрес следующей команды).
  Поэтому подпрограмма должна вернуть стек в первоначальное состояние перед выходом.
  Аргументы в подпрограмму можно передавать через регистры.

  Команда RET переходит по адресу, лежащему на вершине стека.
*/

/* Байт-код.
  Всего 21 команда. Для их хранения достаточно 5 бит, возьмем для простоты 8 бит (байт).
  Пусть команды в нашем эмуляторе будут иметь разный размер, в зависимости от типа.
  Первый байт любой команды будет содержать код команды.
  Команды без операнда будут иметь размер 1 байт (только код команды).
  Команды, у которых операнд регистр, будут состоять из двух байтов (во втором байте номер регистра).
  Команды с метками будут состоять из трех байт. Два байта выделим под адрес,
  в который будет преобразована символьная метка.
  Это ограничивает наше адресное пространство 65536 байтами,
  но мы пока не собираемся писать больших программ.
  Команда PUSHR value0 будет состоять из пяти байтов. Четыре байта предназначены для
  четырехбайтового целого числа.
*/

#include <cstdint>

// opcodes
enum class Opcode : uint8_t
{
    BEGIN = 0x0,
    END = 0x1,
    PUSH = 0x2,
    POP = 0x3,
    PUSHR = 0x4,
    POPR = 0x5,
    ADD = 0x6,
    SUB = 0x7,
    MUL = 0x8,
    DIV = 0x9,
    OUT = 0xA,
    IN = 0xB,
    JMP = 0xC,
    JEQ = 0xD,
    JNE = 0xE,
    JA = 0xF,
    JAE = 0x10,
    JB = 0x11,
    JBE = 0x12,
    CALL = 0x13,
    RET = 0x14,
};

#endif
